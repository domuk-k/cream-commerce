# 주문과 결제를 구분합니다

> 주문과 결제를 분리하면, 주문은 성공해도 결제(포인트/쿠폰/재고 자원 차감)에서 재검증이 필요하고
> 실패할 수 있는데요?

해결 방법은 결국 락(Lock) 범위와 위치 조정인데, 이건 트레이드오프입니다.

1. “주문 생성” 시점에 락을 걸고 자원 예약
    - 주문을 받을 때 미리 자원을 임시 차감하거나 예약 처리
    - ✅ 실패율 ↓
    - ❌ 락 유지 시간 ↑, 롤백 필요, 주문 취소 재처리 복잡

2. 방법 2: “결제 시점”에 자원 확인 및 차감
    - 현실적이고, 시스템 부하 덜함
    - ✅ 단순한 구현
    - ❌ 사용자는 주문했지만 결제 실패 가능성 존재

# 주문 생성

사용자 요청에 따라 "주문 객체 생성"

```mermaid
sequenceDiagram
    actor 사용자
    participant 주문
    participant 상품
    participant 쿠폰
    participant 포인트
    participant 결제
    사용자 ->> 주문: 주문 요청
    activate 주문
    주문 ->> 상품: 상품 존재/재고 확인
    opt 쿠폰 사용시
        주문 ->> 쿠폰: 쿠폰 유효성 확인
    end
    주문 ->> 포인트: 잔액 확인
    주문 ->> 주문: 주문 객체 생성 (PENDING)
    주문 ->> 결제: 결제 요청
    deactivate 주문
    activate 결제
    note right of 결제: 결제처리
    주문 ->> 사용자: 결제 대기
    결제 ->> 주문: 결제 성공
    deactivate 결제
    주문 ->> 사용자: 결제 성공
```

# 결제 처리

- 주문 도메인의 호출에 따라 "리소스 차감".
- 차감가능성 검증을 선행해서 락 지속시간을 줄이고 롤백가능성 줄임(?)
  (롤백 예방보다 롤백이 쉬운 구조가 더 중요하지않나..)
- 가장 취약한(공유되는) 상품재고에 대한 조회-차감이 붙어야 할듯

```mermaid
sequenceDiagram
    participant 주문
    participant 결제
    participant 쿠폰
    participant 포인트
    participant 상품
    주문 ->> 결제: 결제 요청
    activate 결제
%% Step 1: 선검증 (락 없음)
    결제 ->> 쿠폰: 유효성 확인
    결제 ->> 포인트: 잔액 확인
%% Step 2: 상품 재고 검증+차감 포함한 최종 처리
    결제 ->> 상품: 재고 확인 및 차감
    결제 ->> 포인트: 포인트 차감
    결제 ->> 쿠폰: 쿠폰 사용 처리
    결제 ->> 주문: 주문 상태 → COMPLETED
    deactivate 결제
```

# 주문 성공 transition effect

```mermaid
sequenceDiagram
    participant 주문
    participant 외부전송기
    participant 외부 데이터 플랫폼들
    주문 ->> 외부전송기: 주문 완료 후 전송 요청
    외부전송기 ->> 외부 데이터 플랫폼들: 주문 정보 전송
    외부 데이터 플랫폼들 -->> 외부전송기: 수신 완료 응답
```